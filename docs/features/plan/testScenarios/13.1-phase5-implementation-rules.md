# 13.1 Phase 5 Implementation Rules

## Overview
These rules are derived from the successful implementation of Phase 5 enhancements for the Goal Creation Form and Task Modals, focusing on accessibility, loading states, error recovery, and API integration patterns.

## 1. API Integration Rules

### 1.1 Authentication Headers
**ALWAYS** include both authentication headers for API Gateway endpoints:
```typescript
headers: {
  'Content-Type': 'application/json',
  Authorization: `Bearer ${token}`,
  'x-api-key': import.meta.env.VITE_API_GATEWAY_KEY || '',
}
```

**Pattern**: All API calls must include both `Authorization` and `x-api-key` headers for consistency.

### 1.2 Error Handling and Debugging
**ALWAYS** add detailed error logging for API calls:
```typescript
if (!response.ok) {
  const errorBody = await response.json().catch(() => ({}));
  const message = errorBody.detail || response.statusText || 'Operation failed';
  console.error('API Error:', {
    status: response.status,
    statusText: response.statusText,
    errorBody,
    url,
    input
  });
  throw new Error(message);
}
```

**Pattern**: Log comprehensive error details including status, response body, URL, and input data for debugging.

### 1.3 API Endpoint Consistency
**ENSURE** API endpoints follow consistent patterns:
- Create operations: `/quests/createTask`
- Update operations: `/quests/tasks/${id}`
- Delete operations: `/quests/tasks/${id}`

**Pattern**: Use RESTful conventions with clear resource hierarchy.

## 2. Form State Management Rules

### 2.1 Validation Error Clearing
**ALWAYS** clear validation errors when user starts typing:
```typescript
const handleFieldChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.value);
  if (errors.fieldName) {
    setErrors(prev => {
      const { fieldName, ...rest } = prev;
      return rest;
    });
  }
  if (hasValidationErrors) {
    setHasValidationErrors(false);
  }
};
```

**Pattern**: Clear field-specific errors and global validation state on user input.

### 2.2 Button State Management
**ENSURE** buttons are properly enabled/disabled based on validation state:
```typescript
disabled={submitting || isLoading || hasValidationErrors}
```

**Pattern**: Disable buttons during operations and when validation errors exist.

### 2.3 useEffect Dependencies
**AVOID** including function dependencies that recreate on every render:
```typescript
// ❌ BAD - Causes infinite loops
useEffect(() => {
  // logic
}, [tasks, clearError, clearAll]);

// ✅ GOOD - Only include stable dependencies
useEffect(() => {
  // logic
}, [tasks]);
```

**Pattern**: Only include dependencies that are stable or won't cause infinite re-renders.

## 3. Accessibility Rules

### 3.1 ARIA Live Regions
**ALWAYS** provide ARIA live regions for dynamic content:
```typescript
<ARIALiveRegion 
  message="" 
  priority="polite" 
  className="sr-only"
/>
```

**Pattern**: Use ARIA live regions for screen reader announcements of dynamic content changes.

### 3.2 Focus Management
**IMPLEMENT** proper focus management for form interactions:
```typescript
const {
  containerRef,
  focusFirstError,
  focusFirst,
  handleKeyDown
} = useFocusManagement({
  focusOnError: true,
  restoreFocus: true
});
```

**Pattern**: Use dedicated focus management hooks for complex form interactions.

### 3.3 Error Announcements
**ANNOUNCE** validation errors to screen readers:
```typescript
if (Object.keys(newErrors).length > 0) {
  setHasValidationErrors(true);
  announce(FormAnnouncements.validationError('form'), 'assertive');
}
```

**Pattern**: Use assertive priority for error announcements, polite for success messages.

## 4. Loading State Rules

### 4.1 Skeleton Loading
**USE** skeleton loading for initial data fetching:
```typescript
if (isLoading && !Object.values(loadingStates).some(Boolean)) {
  return <SkeletonFormField type="input" showLabel={true} />;
}
```

**Pattern**: Show skeleton loading during initial load, specific loading states for operations.

### 4.2 Loading Indicators
**PROVIDE** clear loading indicators for async operations:
```typescript
{loadingStates[`operation-${id}`] ? (
  <>
    <Loader2 className="h-4 w-4 animate-spin mr-1" />
    {translations?.saving || 'Saving...'}
  </>
) : (
  <>
    <Check className="h-4 w-4 mr-1" />
    {translations?.save || 'Save'}
  </>
)}
```

**Pattern**: Use consistent loading indicators with descriptive text.

## 5. Error Recovery Rules

### 5.1 Network Error Handling
**IMPLEMENT** network error recovery mechanisms:
```typescript
<NetworkErrorRecovery
  isOnline={isOnline}
  hasError={hasError}
  errorMessage={errorMessage}
  onRetry={handleRetry}
  onCheckStatus={handleCheckStatus}
  showAutoRetry={true}
  autoRetryDelay={5}
  maxAutoRetries={3}
  variant="inline"
/>
```

**Pattern**: Provide retry mechanisms and network status indicators.

### 5.2 Field-Level Error Display
**DISPLAY** errors at the field level with proper ARIA attributes:
```typescript
<input
  aria-invalid={!!errors.fieldName}
  aria-describedby={errors.fieldName ? `error-fieldName-${id}` : undefined}
  className={`${errors.fieldName ? 'border-red-500' : 'border-gray-300'}`}
/>
{errors.fieldName && (
  <p id={`error-fieldName-${id}`} className="text-xs text-red-600 mt-1" role="alert">
    {errors.fieldName}
  </p>
)}
```

**Pattern**: Use ARIA attributes and visual indicators for field-level errors.

## 6. Internationalization Rules

### 6.1 Translation Structure
**ORGANIZE** translations by feature/component:
```typescript
interface GoalsTranslations {
  fields: {
    title: string;
    dueAt: string;
    tags: string;
    status: string;
  };
  validation: {
    titleRequired: string;
    dueAtRequired: string;
    tagsRequired: string;
  };
  actions: {
    create: string;
    update: string;
    delete: string;
  };
}
```

**Pattern**: Use nested interfaces for organized translation structure.

### 6.2 Safe Translation Access
**ALWAYS** use safe access for translations:
```typescript
const goalsTranslations = (t as any)?.goals;
const commonTranslations = (t as any)?.common;

// Use with fallbacks
{goalsTranslations?.fields?.title || 'Title'}
```

**Pattern**: Use optional chaining with fallback values for translation safety.

## 7. Component Architecture Rules

### 7.1 Custom Hooks
**EXTRACT** reusable logic into custom hooks:
```typescript
// Focus management
const useFocusManagement = (options) => { /* ... */ };

// Network status
const useNetworkStatus = () => { /* ... */ };

// ARIA announcements
const useARIALiveAnnouncements = () => { /* ... */ };
```

**Pattern**: Create focused, reusable hooks for complex functionality.

### 7.2 Component Composition
**COMPOSE** complex components from smaller, focused components:
```typescript
<Dialog>
  <ARIALiveRegion />
  <NetworkErrorRecovery />
  <DialogContent>
    <SkeletonFormField />
    {/* Main content */}
  </DialogContent>
</Dialog>
```

**Pattern**: Use composition over complex monolithic components.

## 8. Testing Rules

### 8.1 Error Scenarios
**TEST** all error scenarios including:
- Network failures
- Validation errors
- API errors
- Authentication failures

**Pattern**: Comprehensive error testing ensures robust user experience.

### 8.2 Accessibility Testing
**VERIFY** accessibility features:
- Screen reader compatibility
- Keyboard navigation
- Focus management
- ARIA attributes

**Pattern**: Test accessibility features to ensure inclusive design.

## 9. Performance Rules

### 9.1 Debounced Validation
**USE** debounced validation for real-time feedback:
```typescript
const debouncedValidation = useDebouncedCallback(
  (data) => validate(data),
  300
);
```

**Pattern**: Debounce expensive operations like validation.

### 9.2 Memoization
**MEMOIZE** expensive calculations:
```typescript
const sortedTasks = useMemo(() => {
  return tasks.sort((a, b) => /* sorting logic */);
}, [tasks, sortColumn, sortDirection]);
```

**Pattern**: Use memoization for expensive computations.

## 10. Documentation Rules

### 10.1 Implementation Documentation
**DOCUMENT** all significant changes:
- What was changed
- Why it was changed
- How to test the changes
- Any breaking changes

**Pattern**: Maintain comprehensive documentation for future maintenance.

### 10.2 Error Debugging
**INCLUDE** debugging information in error logs:
- Request details
- Response details
- User context
- Timestamp information

**Pattern**: Provide sufficient debugging information for troubleshooting.

## Summary

These rules ensure:
- ✅ Consistent API integration patterns
- ✅ Robust error handling and recovery
- ✅ Accessible user interfaces
- ✅ Proper state management
- ✅ Internationalization support
- ✅ Maintainable component architecture
- ✅ Comprehensive testing coverage
- ✅ Performance optimization
- ✅ Clear documentation

Following these rules will help maintain code quality, user experience, and maintainability across the GoalsGuild application.
