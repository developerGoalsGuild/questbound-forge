# 17.1 â€“ Compute Goal Progress % (Backend) - Technical Plan

## Brief Description

This feature implements backend computation of goal progress percentage using a hybrid approach that combines both task completion status and time-based progress (70% task, 30% time). The system calculates progress by analyzing completed tasks versus total tasks for each goal, while also considering time elapsed versus deadline, providing comprehensive progress tracking for users. **NEW**: The dashboard now features a dual progress bar component that displays both task progress and time progress side by side, with visual milestone markers and enhanced progress metrics. The top goals list displays comprehensive progress visualization including milestones, task completion counts, and dual progress indicators across all goal management interfaces.

## Context

Based on the existing codebase analysis:
- **Current State**: Goals and tasks are fully implemented with CRUD operations
- **Missing**: Progress calculation and milestone tracking
- **Dependencies**: Task 15.5 (Mark task as complete) is completed
- **Architecture**: FastAPI service with DynamoDB single-table design

## Files and Functions to Change

### Backend Service Files

#### 1. `backend/services/quest-service/app/models.py`
**Changes:**
- Add `GoalProgressResponse` model for progress calculation results
- Add `Milestone` model for milestone tracking
- Add `progress` field to `GoalResponse` model
- Add `milestones` field to `GoalResponse` model

#### 2. `backend/services/quest-service/app/main.py`
**Changes:**
- Add `compute_goal_progress()` function for progress calculation logic
- Add `get_goal_tasks()` helper function to fetch tasks for a goal
- Add `calculate_milestones()` function for milestone computation
- Add progress computation to task update operations (triggered by AppSync)
- Add progress computation to goal update operations

#### 3. `backend/services/quest-service/app/utils.py`
**Changes:**
- Add `_calculate_progress_percentage()` utility function
- Add `_determine_milestones()` utility function
- Add `_format_progress_response()` utility function

### Database Schema Updates

#### 4. `backend/infra/terraform2/graphql/schema.graphql`
**Changes:**
- Add `progress: Float` field to `Goal` type
- Add `milestones: [Milestone!]` field to `Goal` type
- Add `Milestone` type definition:
  ```graphql
  type Milestone {
    id: ID!
    name: String!
    percentage: Float!
    achieved: Boolean!
    achievedAt: AWSTimestamp
  }
  ```
- Add `GoalProgress` type definition:
  ```graphql
  type GoalProgress {
    goalId: ID!
    progressPercentage: Float!
    taskProgress: Float!
    timeProgress: Float!
    completedTasks: Int!
    totalTasks: Int!
    milestones: [Milestone!]!
    lastUpdated: AWSTimestamp!
  }
  ```
- Add `goalProgress(goalId: ID!): GoalProgress!` query
- Add `myGoalsProgress: [GoalProgress!]!` query

### AppSync Resolvers

#### 5. `backend/infra/terraform2/resolvers/goalProgress.js` (New File)
**Changes:**
- Create VTL resolver for `goalProgress` query
- Query DynamoDB for goal and tasks
- Calculate progress percentage
- Return progress data with milestones

#### 6. `backend/infra/terraform2/resolvers/myGoalsProgress.js` (New File)
**Changes:**
- Create VTL resolver for `myGoalsProgress` query
- Query all user goals with progress data
- Calculate progress for each goal
- Return array of progress data

#### 7. `backend/infra/terraform2/resolvers/goal.js` (Modify Existing)
**Changes:**
- Add progress calculation to existing goal resolver
- Include progress and milestones in goal response
- Maintain backward compatibility

### Frontend Integration Files

#### 8. `frontend/src/lib/apiGoal.ts`
**Changes:**
- Add `loadGoalsWithProgress()` function to fetch goals with backend progress data
- Update `loadDashboardGoals()` to use backend progress calculation
- Add `getGoalProgress(goalId: string)` function for individual goal progress
- Add `getAllGoalsProgress()` function for dashboard progress overview

#### 9. `frontend/src/lib/goalProgress.ts`
**Changes:**
- Add `calculateTaskProgress()` function to use backend progress data
- Update `GoalProgressData` interface to include backend progress fields
- Add `ProgressWithMilestones` interface for enhanced progress display
- Update `sortGoals()` to support task-based progress sorting
- Add `formatMilestoneText()` utility function

#### 10. `frontend/src/components/dashboard/GoalsButton.tsx`
**Changes:**
- Update to use backend progress calculation instead of time-based
- Add milestone display in goal cards
- Add progress metrics summary (completed tasks, total tasks)
- **NEW**: Replace single progress bar with dual progress bar component
- **NEW**: Display both task progress and time progress side by side
- **NEW**: Add milestone achievement indicators with visual markers
- **NEW**: Add task progress sorting options to goals list
- **NEW**: Enhanced goal cards with comprehensive progress visualization

#### 11. `frontend/src/components/dashboards/UserDashboard.tsx`
**Changes:**
- **NEW**: Add dedicated progress metrics section with 3 cards:
  - Overall Progress card showing hybrid progress percentage
  - Task Progress card showing task completion with completed/total counts
  - Time Progress card showing time-based progress percentage
- Add progress metrics cards (completion rate, milestones achieved)
- Update stats overview to include task-based progress data
- Add progress trends and analytics display

#### 12. `frontend/src/i18n/goalDashboard.ts`
**Changes:**
- Add translations for milestone-related text
- **NEW**: Add comprehensive progress metrics translations:
  - `progressMetrics.overall` - Overall Progress
  - `progressMetrics.taskProgress` - Task Progress  
  - `progressMetrics.timeProgress` - Time Progress
  - `progressMetrics.completedTasks` - Completed Tasks
  - `progressMetrics.totalTasks` - Total Tasks
  - `progressMetrics.milestones.title/achieved/upcoming` - Milestone labels
- **NEW**: Add task progress sorting options translations:
  - `taskProgressAsc` - Task Progress (lowest first)
  - `taskProgressDesc` - Task Progress (highest first)
- Add progress metrics translations
- Add task completion status translations

#### 13. `frontend/src/components/ui/DualProgressBar.tsx` (New File)
**Changes:**
- **NEW**: Create reusable dual progress bar component
- **NEW**: Display overall progress bar with milestone markers
- **NEW**: Display task progress bar with completion percentage
- **NEW**: Display time progress bar with time-based percentage
- **NEW**: Visual milestone markers (green for achieved, gray for upcoming)
- **NEW**: Color-coded progress bars based on progress levels
- **NEW**: Responsive design with proper accessibility support
- **NEW**: Configurable display options (show/hide milestones, labels)

#### 14. `frontend/src/pages/goals/GoalDetails.tsx`
**Changes:**
- **NEW**: Replace single progress bar with dual progress bar component
- **NEW**: Display comprehensive progress visualization on goal details page
- **NEW**: Show milestone information and achievement status
- **NEW**: Enhanced progress section with task and time metrics

### Test Files

#### 15. `backend/services/quest-service/tests/test_goals.py`
**Changes:**
- Add `test_compute_goal_progress_success()`
- Add `test_compute_goal_progress_no_tasks()`
- Add `test_compute_goal_progress_all_completed()`
- Add `test_compute_goal_progress_mixed_status()`
- Add `test_compute_goal_progress_invalid_goal()`
- Add `test_compute_goal_progress_unauthorized()`

#### 16. `backend/services/quest-service/tests/test_progress.py` (New File)
**Changes:**
- Create comprehensive progress calculation tests
- Add milestone calculation tests
- Add edge case tests (empty goals, single task, etc.)

### Integration Tests

#### 17. `frontend/src/components/dashboard/__tests__/GoalsButton.test.tsx`
**Changes:**
- Add tests for backend progress integration
- Test milestone display functionality
- Test progress metrics calculation
- Test task-based progress sorting

#### 18. `frontend/src/lib/__tests__/goalProgress.test.ts` (New File)
**Changes:**
- Create tests for task-based progress calculation
- Test milestone formatting functions
- Test progress data transformation
- Test sorting with backend progress data

#### 19. `tests/integration/goalProgressTest.js` (New File)
**Changes:**
- Create Selenium test for goal progress visualization
- Test progress bar updates when tasks are completed
- Test milestone display functionality
- Test progress calculation accuracy

#### 20. `scripts/run-goal-progress-tests.ps1` (New File)
**Changes:**
- Create PowerShell script to run goal progress integration tests
- Include test data setup and cleanup
- Add progress validation checks

### Terraform Infrastructure

#### 21. `backend/infra/terraform2/lambdas/quest-service.tf`
**Changes:**
- Update Lambda function environment variables if needed
- Ensure DynamoDB permissions include progress calculation queries

## Algorithms and Implementation Details

### Hybrid Progress Calculation Algorithm

```python
def compute_goal_progress(goal_id: str, user_id: str) -> GoalProgressResponse:
    """
    Calculate goal progress using hybrid approach: task completion + time-based progress.
    
    Requirements:
    - Fixed 70/30 weight split (task/time)
    - Goals without tasks show 0% progress
    - Deadline is mandatory for all goals
    - Store progress data in Goal record
    - Asynchronous recalculation on task operations
    """
    
    try:
        # Step 1: Get all tasks for the goal
        tasks = get_goal_tasks(goal_id, user_id)
        
        # Step 2: Calculate task completion progress
        total_tasks = len(tasks)
        completed_tasks = len([t for t in tasks if t.status == "completed"])
        
        # Goals without tasks show 0% progress (not time-based fallback)
        task_progress = 0.0
        if total_tasks > 0:
            task_progress = (completed_tasks / total_tasks) * 100
        
        # Step 3: Calculate time-based progress (deadline is mandatory)
        goal = get_goal(goal_id, user_id)
        time_progress = calculate_time_progress(goal)
        
        # Step 4: Calculate hybrid progress (fixed 70/30 weight split)
        hybrid_progress = (task_progress * 0.7) + (time_progress * 0.3)
        
        # Step 5: Determine milestones (fixed thresholds, non-retroactive)
        milestones = calculate_milestones(hybrid_progress, total_tasks)
        
        # Step 6: Determine urgency and overdue status
        is_overdue = is_goal_overdue(goal)
        is_urgent = is_goal_urgent(goal)
        
        return GoalProgressResponse(
            goal_id=goal_id,
            progress_percentage=round(hybrid_progress, 2),
            task_progress=round(task_progress, 2),
            time_progress=round(time_progress, 2),
            completed_tasks=completed_tasks,
            total_tasks=total_tasks,
            milestones=milestones,
            last_updated=int(time.time() * 1000),
            is_overdue=is_overdue,
            is_urgent=is_urgent
        )
        
    except Exception as e:
        # Log error to CloudWatch and continue API operation
        logger.error(f"Progress calculation failed for goal {goal_id}: {e}")
        # Return minimal progress data to maintain API functionality
        return GoalProgressResponse(
            goal_id=goal_id,
            progress_percentage=0.0,
            task_progress=0.0,
            time_progress=0.0,
            completed_tasks=0,
            total_tasks=0,
            milestones=[],
            last_updated=int(time.time() * 1000),
            is_overdue=False,
            is_urgent=False
        )

def calculate_time_progress(goal: Dict) -> float:
    """
    Calculate time-based progress percentage.
    Formula: (current_date - creation_date) / (deadline - creation_date) * 100
    """
    now = datetime.now()
    created = datetime.fromtimestamp(goal['createdAt'] / 1000)
    deadline = datetime.strptime(goal['deadline'], '%Y-%m-%d') if goal.get('deadline') else None
    
    if not deadline:
        return 0.0
    
    total_days = (deadline - created).days
    elapsed_days = (now - created).days
    
    if total_days <= 0:
        return 100.0 if now > deadline else 0.0
    
    time_progress = min(100.0, max(0.0, (elapsed_days / total_days) * 100))
    
    # If overdue, return 100% but mark as overdue
    if now > deadline:
        return 100.0
    
    return time_progress
```

### Progress Calculation Strategy

#### Hybrid Approach Benefits
1. **Task Completion Priority (70% weight)**: Ensures that actual work completion drives progress
2. **Time Pressure Consideration (30% weight)**: Accounts for deadline urgency and time management
3. **Balanced Assessment**: Prevents goals from appearing complete based solely on time elapsed
4. **Motivation Factor**: Users see progress from both completing tasks and staying on schedule

#### Progress Scenarios
- **Ahead of Schedule**: High task progress + low time progress = Good progress
- **On Track**: Balanced task and time progress = Steady progress  
- **Behind Schedule**: Low task progress + high time progress = Needs attention
- **Overdue**: Any task progress + 100% time progress = Urgent action required

#### Weight Configuration
The 70/30 split can be configured via environment variables:
- `TASK_PROGRESS_WEIGHT`: Default 0.7 (70%)
- `TIME_PROGRESS_WEIGHT`: Default 0.3 (30%)
- Future enhancement: User-configurable weights per goal category

### Milestone Calculation Algorithm

```python
def calculate_milestones(progress_percentage: float, goal_id: str) -> List[Milestone]:
    """
    Calculate milestones based on current progress percentage (non-retroactive).
    
    Requirements:
    - Fixed thresholds: 25%, 50%, 75%, 100%
    - Standard milestone names
    - Non-retroactive: only show current progress level
    - Display milestone markers in progress bar
    """
    milestones = []
    
    # Fixed milestone thresholds and names
    milestone_configs = [
        (25.0, "First Quarter"),
        (50.0, "Halfway Point"), 
        (75.0, "Three Quarters"),
        (100.0, "Complete")
    ]
    
    for threshold, name in milestone_configs:
        # Non-retroactive: only add milestone if current progress >= threshold
        if progress_percentage >= threshold:
            milestones.append(Milestone(
                id=f"milestone_{int(threshold)}_{goal_id}",
                name=name,
                percentage=threshold,
                achieved=True,
                achieved_at=int(time.time() * 1000),
                description=f"Reached {name} milestone"
            ))
        else:
            # Add unachieved milestone for progress bar markers
            milestones.append(Milestone(
                id=f"milestone_{int(threshold)}_{goal_id}",
                name=name,
                percentage=threshold,
                achieved=False,
                achieved_at=None,
                description=f"Next milestone: {name}"
            ))
    
    return milestones
```

### Database Query Patterns

```python
def get_goal_tasks(goal_id: str, user_id: str) -> List[Dict]:
    """
    Query DynamoDB for all tasks belonging to a specific goal.
    
    Query Pattern:
    - PK: USER#{user_id}
    - SK: begins_with(TASK#)
    - Filter: goalId = goal_id
    """
    response = table.query(
        KeyConditionExpression="PK = :pk AND begins_with(SK, :sk_prefix)",
        FilterExpression="goalId = :goal_id",
        ExpressionAttributeValues={
            ":pk": f"USER#{user_id}",
            ":sk_prefix": "TASK#",
            ":goal_id": goal_id
        }
    )
    return response.get("Items", [])
```

### AppSync Resolver Implementation

#### Goal Progress Resolver (VTL)
```javascript
// backend/infra/terraform2/resolvers/goalProgress.js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
    const { goalId } = ctx.args;
    const userId = ctx.identity.sub;
    
    return {
        operation: 'Query',
        query: {
            expression: 'PK = :pk AND begins_with(SK, :sk_prefix)',
            expressionValues: {
                ':pk': `USER#${userId}`,
                ':sk_prefix': 'TASK#'
            }
        },
        filter: {
            expression: 'goalId = :goalId',
            expressionValues: {
                ':goalId': goalId
            }
        }
    };
}

export function response(ctx) {
    if (ctx.error) {
        util.error(ctx.error.message, ctx.error.type);
    }
    
    const tasks = ctx.result.items || [];
    const totalTasks = tasks.length;
    const completedTasks = tasks.filter(task => task.status === 'completed').length;
    
    // Calculate task completion progress
    const taskProgress = totalTasks === 0 ? 0 : (completedTasks / totalTasks) * 100;
    
    // Calculate time-based progress (simplified for VTL)
    const now = new Date();
    const goal = ctx.result.goal || {};
    const created = new Date(goal.createdAt);
    const deadline = goal.deadline ? new Date(goal.deadline) : null;
    
    let timeProgress = 0;
    if (deadline) {
        const totalDays = Math.ceil((deadline - created) / (1000 * 60 * 60 * 24));
        const elapsedDays = Math.ceil((now - created) / (1000 * 60 * 60 * 24));
        timeProgress = totalDays > 0 ? Math.min(100, Math.max(0, (elapsedDays / totalDays) * 100)) : 0;
    }
    
    // Calculate hybrid progress (70% task, 30% time)
    const progressPercentage = (taskProgress * 0.7) + (timeProgress * 0.3);
    
    // Calculate milestones
    const milestones = [];
    if (progressPercentage >= 25) milestones.push({ name: 'First Quarter', percentage: 25, achieved: true });
    if (progressPercentage >= 50) milestones.push({ name: 'Halfway Point', percentage: 50, achieved: true });
    if (progressPercentage >= 75) milestones.push({ name: 'Three Quarters', percentage: 75, achieved: true });
    if (progressPercentage >= 100) milestones.push({ name: 'Complete', percentage: 100, achieved: true });
    
    return {
        goalId: ctx.args.goalId,
        progressPercentage: Math.round(progressPercentage * 100) / 100,
        taskProgress: Math.round(taskProgress * 100) / 100,
        timeProgress: Math.round(timeProgress * 100) / 100,
        completedTasks,
        totalTasks,
        milestones,
        lastUpdated: Date.now()
    };
}
```

### Frontend Integration Details

#### Enhanced Goal Progress Data Interface
```typescript
// frontend/src/lib/goalProgress.ts
export interface GoalProgressData {
  id: string;
  title: string;
  description?: string;
  deadline?: string;
  status: string;
  createdAt: number;
  updatedAt: number;
  tags: string[];
  // New backend progress fields
  progress?: number; // Hybrid progress percentage (task + time)
  taskProgress?: number; // Task completion progress
  timeProgress?: number; // Time-based progress
  completedTasks?: number;
  totalTasks?: number;
  milestones?: Milestone[];
}

export interface Milestone {
  id: string;
  name: string;
  percentage: number;
  achieved: boolean;
  achievedAt?: number;
}

export interface ProgressWithMilestones extends ProgressResult {
  completedTasks: number;
  totalTasks: number;
  milestones: Milestone[];
  lastUpdated: number;
}
```

#### Dashboard Progress Metrics Integration
```typescript
// frontend/src/lib/apiGoal.ts
export async function loadGoalsWithProgress(sortBy: string = 'deadline-asc') {
  try {
    const data = await graphqlRaw<{
      myGoals: Array<{
        id: string;
        title: string;
        description: string;
        tags: string[];
        deadline: string | null;
        status: string;
        createdAt: number;
        updatedAt: number;
        progress: number;
        completedTasks: number;
        totalTasks: number;
        milestones: Milestone[];
      }>;
    }>(`query MyGoalsWithProgress { 
      myGoals { 
        id 
        title 
        description 
        tags
        deadline 
        status 
        createdAt
        updatedAt
        progress
        completedTasks
        totalTasks
        milestones {
          id
          name
          percentage
          achieved
          achievedAt
        }
      } 
    }`);

    const activeGoals = (data?.myGoals ?? []).filter(goal => goal.status === 'active');
    return sortGoals(activeGoals, sortBy);
  } catch (e: any) {
    console.error('[loadGoalsWithProgress] GraphQL error:', e?.errors || e?.message || e);
    return [];
  }
}
```

#### Enhanced Dashboard Display with Dual Progress
```typescript
// frontend/src/components/dashboard/GoalsButton.tsx
const GoalCard = ({ goal }: { goal: GoalProgressData }) => {
  const progress = goal.progress ?? 0;
  const taskProgress = goal.taskProgress ?? 0;
  const timeProgress = goal.timeProgress ?? 0;
  const completedTasks = goal.completedTasks ?? 0;
  const totalTasks = goal.totalTasks ?? 0;
  
  return (
    <div className="p-3 border border-border rounded-lg bg-card">
      {/* Goal Title and Category */}
      <div className="flex items-start justify-between mb-2">
        <h4 className="font-medium text-sm leading-tight pr-2">
          {goal.title}
        </h4>
        {goal.tags.length > 0 && (
          <span className={`px-2 py-1 text-xs rounded-full ${getCategoryBadgeColor(goal.tags[0])} flex-shrink-0`}>
            {goal.tags[0]}
          </span>
        )}
      </div>

      {/* Task Progress Metrics */}
      <div className="flex items-center justify-between text-xs text-muted-foreground mb-2">
        <span className="flex items-center gap-1">
          <Target className="w-3 h-3" />
          {completedTasks}/{totalTasks} tasks completed
        </span>
        <span className="font-medium">
          {formatProgressPercentage(progress)} overall
        </span>
      </div>

      {/* Dual Progress Bars */}
      <div className="space-y-2 mb-2">
        {/* Overall Progress Bar with Milestone Markers */}
        <div className="space-y-1">
          <div className="flex items-center justify-between text-xs text-muted-foreground">
            <span>Overall Progress</span>
            <span className="font-medium">{formatProgressPercentage(progress)}</span>
          </div>
          <div className="relative w-full h-2 rounded-full bg-gray-200">
            {/* Progress Bar */}
            <div 
              className="h-2 rounded-full transition-all duration-300 bg-blue-500"
              style={{ width: `${progress}%` }}
            />
            {/* Milestone Markers */}
            {goal.milestones && goal.milestones.map((milestone, index) => (
              <div
                key={milestone.id}
                className="absolute top-0 w-1 h-2 bg-gray-400 rounded-full"
                style={{ left: `${milestone.percentage}%`, transform: 'translateX(-50%)' }}
                title={`${milestone.name} (${milestone.percentage}%)`}
              >
                {/* Milestone Arrow */}
                <div className={`absolute -top-1 left-1/2 transform -translate-x-1/2 w-0 h-0 ${
                  milestone.achieved ? 'border-b-2 border-b-green-500' : 'border-b-2 border-b-gray-400'
                } border-l-2 border-l-transparent border-r-2 border-r-transparent`} />
              </div>
            ))}
          </div>
        </div>

        {/* Task vs Time Progress Comparison */}
        <div className="grid grid-cols-2 gap-2">
          <div className="space-y-1">
            <div className="flex items-center justify-between text-xs text-muted-foreground">
              <span>Tasks</span>
              <span className="font-medium">{formatProgressPercentage(taskProgress)}</span>
            </div>
            <div className="w-full h-1.5 rounded-full bg-gray-200">
              <div 
                className="h-1.5 rounded-full transition-all duration-300 bg-green-500"
                style={{ width: `${taskProgress}%` }}
              />
            </div>
          </div>
          <div className="space-y-1">
            <div className="flex items-center justify-between text-xs text-muted-foreground">
              <span>Time</span>
              <span className="font-medium">{formatProgressPercentage(timeProgress)}</span>
            </div>
            <div className="w-full h-1.5 rounded-full bg-gray-200">
              <div 
                className="h-1.5 rounded-full transition-all duration-300 bg-orange-500"
                style={{ width: `${timeProgress}%` }}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Milestones */}
      {goal.milestones && goal.milestones.length > 0 && (
        <div className="flex items-center gap-1 text-xs text-muted-foreground">
          <Trophy className="w-3 h-3" />
          <span>
            {goal.milestones.filter(m => m.achieved).length}/{goal.milestones.length} milestones
          </span>
        </div>
      )}
    </div>
  );
};
```

## API Endpoints

### AppSync GraphQL Queries

#### 1. `goalProgress(goalId: ID!): GoalProgress!`
**Purpose:** Get progress information for a specific goal
**Authentication:** Required (Lambda auth)
**Response:** `GoalProgress` type

#### 2. `myGoalsProgress: [GoalProgress!]!`
**Purpose:** Get progress for all user goals
**Authentication:** Required (Lambda auth)
**Response:** `List[GoalProgress]`

### Modified AppSync Queries

#### 1. `goal(goalId: ID!): Goal`
**Changes:** Include progress data in goal response
**New Fields:** `progress: Float`, `milestones: [Milestone!]`

#### 2. `myGoals: [Goal!]!`
**Changes:** Include progress data for all user goals
**New Fields:** `progress: Float`, `milestones: [Milestone!]`

### REST API Endpoints (Write Operations Only)

#### 1. `PUT /quests/tasks/{task_id}`
**Changes:** Trigger progress recalculation when task status changes
**Side Effects:** Update goal progress automatically

## Error Handling

### Error Scenarios
1. **Goal not found:** Return 404 with appropriate message
2. **Unauthorized access:** Return 401 for invalid JWT
3. **Database errors:** Return 500 with structured error logging
4. **Invalid goal_id:** Return 400 with validation error

### Error Response Format
```json
{
  "detail": "Goal not found",
  "error_code": "GOAL_NOT_FOUND",
  "timestamp": "2025-01-01T00:00:00Z"
}
```

## Performance Considerations

### Caching Strategy
- Cache progress calculations for 5 minutes
- Invalidate cache when tasks are updated
- Use Redis for production caching (future enhancement)

### Database Optimization
- Use GSI1 for efficient task queries
- Implement pagination for goals with many tasks
- Consider batch operations for multiple goal progress

### Response Time Targets
- Single goal progress: < 200ms
- Multiple goals progress: < 500ms
- Progress calculation: < 100ms

## Security Considerations

### Authorization
- Verify user owns the goal before calculating progress
- Validate JWT tokens for all progress endpoints
- Implement rate limiting for progress calculations

### Data Validation
- Validate goal_id format (UUID)
- Sanitize progress percentage values
- Validate milestone data integrity

## Testing Strategy

### Unit Tests
- Test progress calculation with various task states
- Test milestone calculation logic
- Test error handling scenarios
- Test edge cases (no tasks, all completed, etc.)

### Integration Tests
- Test end-to-end progress calculation
- Test progress updates when tasks change
- Test API endpoint responses
- Test database query performance

### Selenium Tests
- Test progress bar visualization
- Test milestone display
- Test progress updates in real-time
- Test cross-browser compatibility

## Deployment Considerations

### Environment Variables
- `PROGRESS_CACHE_TTL`: Cache time-to-live (default: 300 seconds)
- `MILESTONE_THRESHOLDS`: Configurable milestone percentages
- `PROGRESS_BATCH_SIZE`: Batch size for multiple goal progress

### Database Migrations
- No schema changes required (using existing single-table design)
- Add indexes if performance issues arise
- Consider GSI for progress queries if needed

### Monitoring
- Track progress calculation performance
- Monitor error rates for progress endpoints
- Alert on high response times
- Track milestone achievement rates

## Success Criteria

### Functional Requirements
- [ ] Hybrid progress percentage calculated correctly (70% task + 30% time)
- [ ] Task completion progress calculated and displayed separately
- [ ] Time-based progress calculated and displayed separately
- [ ] Milestones generated at 25%, 50%, 75%, and 100% thresholds
- [ ] Progress updates automatically when tasks change status
- [ ] Dashboard displays dual progress bars (overall + task/time breakdown)
- [ ] API endpoints return comprehensive progress data
- [ ] Error handling covers all failure scenarios

### Performance Requirements
- [ ] Progress calculation completes within 100ms
- [ ] API endpoints respond within 200ms
- [ ] Database queries optimized for performance
- [ ] Caching implemented for frequently accessed data

### Quality Requirements
- [ ] Unit test coverage > 90%
- [ ] Integration tests cover all user scenarios
- [ ] Selenium tests verify UI functionality
- [ ] Code follows project conventions and patterns
- [ ] Documentation updated with new endpoints

## Dual Progress Bar Implementation

### Overview
The dual progress bar feature provides users with comprehensive visibility into both task completion progress and time-based progress, implementing the hybrid progress calculation (70% task, 30% time) with visual milestone tracking.

### Key Features Implemented

#### 1. DualProgressBar Component (`frontend/src/components/ui/DualProgressBar.tsx`)
- **Overall Progress Bar**: Displays hybrid progress (70% task + 30% time) with milestone markers
- **Task Progress Bar**: Shows task completion percentage with completed/total task counts
- **Time Progress Bar**: Shows time-based progress percentage
- **Milestone Markers**: Visual indicators at 25%, 50%, 75%, 100% (green for achieved, gray for upcoming)
- **Color-coded Progress**: Different colors based on progress levels
- **Responsive Design**: Adapts to different screen sizes
- **Accessibility**: Proper ARIA labels and screen reader support

#### 2. Enhanced Dashboard Integration
- **UserDashboard**: Added 3 progress metrics cards showing overall, task, and time progress
- **GoalsButton**: Replaced single progress bar with dual progress visualization
- **Goal Details**: Enhanced progress section with comprehensive metrics
- **Sorting Options**: Added task progress sorting to goals list

#### 3. Internationalization Support
- **English, Spanish, French**: Complete translations for all progress metrics
- **New Translation Keys**: 
  - `progressMetrics.overall/taskProgress/timeProgress`
  - `progressMetrics.completedTasks/totalTasks`
  - `progressMetrics.milestones.title/achieved/upcoming`
  - `taskProgressAsc/taskProgressDesc` sorting options

#### 4. Enhanced Utility Functions
- **`calculateTaskProgress()`**: Task-based progress calculation
- **`calculateHybridProgress()`**: 70/30 weighted hybrid calculation
- **`getMilestoneMarkers()`**: Milestone marker generation
- **`formatMilestoneText()`**: Milestone text formatting
- **Enhanced Sorting**: Support for task progress sorting

### Visual Design
- **Milestone Markers**: Green dots for achieved milestones, gray for upcoming
- **Progress Colors**: 
  - Green: 100% complete
  - Blue: 75-99% complete
  - Yellow: 50-74% complete
  - Orange: 25-49% complete
  - Gray: 0-24% complete
- **Responsive Layout**: Cards adapt to screen size
- **Consistent Styling**: Follows project design system

### User Experience Benefits
1. **Clear Progress Visualization**: Users see both task completion and time progress
2. **Milestone Tracking**: Visual indicators show progress achievements
3. **Comprehensive Metrics**: Dashboard shows overall progress statistics
4. **Enhanced Sorting**: Users can sort goals by task progress
5. **Multilingual Support**: Full translation support for all features

## Detailed Implementation Plan

### Phase 1: Backend Foundation (Week 1-2)

#### 1.1 Database Schema Updates
**Duration:** 2 days
**Dependencies:** None
**Tasks:**

**Day 1: Schema Design and Implementation**
- [ ] **Analyze existing schema structure** in `backend/infra/terraform2/graphql/schema.graphql`
  - Review current `Goal` type fields and structure
  - Identify integration points for progress data
  - Plan backward compatibility strategy
- [ ] **Update GraphQL schema** with detailed specifications:
  ```graphql
  # Add to Goal type
  progress: Float
  milestones: [Milestone!]
  
  # New Milestone type
  type Milestone {
    id: ID!
    name: String!
    percentage: Float!
    achieved: Boolean!
    achievedAt: AWSTimestamp
    description: String
  }
  
  # New GoalProgress type
  type GoalProgress {
    goalId: ID!
    progressPercentage: Float!
    taskProgress: Float!
    timeProgress: Float!
    completedTasks: Int!
    totalTasks: Int!
    milestones: [Milestone!]!
    lastUpdated: AWSTimestamp!
    isOverdue: Boolean!
    isUrgent: Boolean!
  }
  
  # New queries
  goalProgress(goalId: ID!): GoalProgress!
  myGoalsProgress: [GoalProgress!]!
  ```

**Day 2: Deployment and Validation**
- [ ] **Deploy schema to development environment**
  - Run `terraform plan` to review changes
  - Execute `terraform apply` for schema deployment
  - Verify AppSync API updates successfully
- [ ] **Schema validation and testing**
  - Test schema compilation in GraphQL playground
  - Verify all new types are accessible
  - Test query syntax and structure
  - Validate backward compatibility with existing queries

#### 1.2 Backend Models and Utilities
**Duration:** 3 days
**Dependencies:** 1.1
**Tasks:**

**Day 1: Pydantic Models Implementation**
- [ ] **Update `backend/services/quest-service/app/models.py`** with detailed model specifications:
  ```python
  # Add to existing models.py
  class Milestone(BaseModel):
      id: str
      name: str
      percentage: float
      achieved: bool
      achieved_at: Optional[int] = None
      description: Optional[str] = None
  
  class GoalProgressResponse(BaseModel):
      goal_id: str
      progress_percentage: float
      task_progress: float
      time_progress: float
      completed_tasks: int
      total_tasks: int
      milestones: List[Milestone]
      last_updated: int
      is_overdue: bool
      is_urgent: bool
  
  # Update existing GoalResponse model
  class GoalResponse(BaseModel):
      # ... existing fields ...
      progress: Optional[float] = None
      milestones: Optional[List[Milestone]] = None
      completed_tasks: Optional[int] = None
      total_tasks: Optional[int] = None
  ```

**Day 2: Progress Calculation Core Logic**
- [ ] **Create `backend/services/quest-service/app/progress.py`** with comprehensive implementation:
  ```python
  # Core progress calculation functions
  def compute_goal_progress(goal_id: str, user_id: str, table) -> GoalProgressResponse:
      """
      Main progress calculation function with detailed error handling
      """
  
  def calculate_time_progress(goal: Dict) -> float:
      """
      Time-based progress calculation with edge case handling
      """
  
  def calculate_milestones(progress_percentage: float, total_tasks: int) -> List[Milestone]:
      """
      Milestone calculation with configurable thresholds
      """
  
  def get_goal_tasks(goal_id: str, user_id: str, table) -> List[Dict]:
      """
      DynamoDB query function for goal tasks
      """
  
  def is_goal_overdue(goal: Dict) -> bool:
      """
      Check if goal is overdue based on deadline
      """
  
  def is_goal_urgent(goal: Dict) -> bool:
      """
      Check if goal is urgent (7 days or less remaining)
      """
  ```

**Day 3: Utility Functions and Integration**
- [ ] **Update `backend/services/quest-service/app/utils.py`** with progress utilities:
  ```python
  def _calculate_progress_percentage(completed: int, total: int) -> float:
      """Calculate percentage with zero-division protection"""
  
  def _determine_milestones(progress: float, thresholds: List[float]) -> List[Milestone]:
      """Determine achieved milestones based on progress"""
  
  def _format_progress_response(goal_id: str, progress_data: Dict) -> GoalProgressResponse:
      """Format progress data into response model"""
  
  def _validate_progress_data(progress_data: Dict) -> bool:
      """Validate progress calculation results"""
  ```
- [ ] **Add configuration management** for progress calculation:
  ```python
  # Add to settings.py
  class ProgressSettings:
      TASK_PROGRESS_WEIGHT: float = 0.7
      TIME_PROGRESS_WEIGHT: float = 0.3
      MILESTONE_THRESHOLDS: List[float] = [25.0, 50.0, 75.0, 100.0]
      URGENT_DAYS_THRESHOLD: int = 7
  ```

#### 1.3 Backend API Integration
**Duration:** 2 days
**Dependencies:** 1.2
**Tasks:**

**Day 1: Main API Integration**
- [ ] **Update `backend/services/quest-service/app/main.py`** with progress integration:
  ```python
  # Import progress calculation functions
  from .progress import compute_goal_progress, get_goal_tasks
  from .models import GoalProgressResponse
  
  # Add progress calculation to task update endpoint
  @app.put("/quests/tasks/{task_id}", response_model=TaskResponse)
  async def update_task(task_id: str, payload: TaskUpdateInput, ...):
      # ... existing task update logic ...
      
      # Trigger progress recalculation after task update
      if payload.status is not None:
          try:
              progress_data = compute_goal_progress(
                  goal_id=task_item.get("goalId"),
                  user_id=auth.user_id,
                  table=table
              )
              # Update goal with progress data
              update_goal_progress(goal_id, progress_data, table)
          except Exception as e:
              logger.warning(f"Progress calculation failed: {e}")
              # Continue with task update even if progress fails
  
  # Add progress calculation to goal update endpoint
  @app.put("/quests/{goal_id}", response_model=GoalResponse)
  async def update_goal(goal_id: str, payload: GoalUpdatePayload, ...):
      # ... existing goal update logic ...
      
      # Trigger progress recalculation if deadline changes
      if payload.deadline is not None:
          try:
              progress_data = compute_goal_progress(goal_id, auth.user_id, table)
              # Update goal with progress data
              update_goal_progress(goal_id, progress_data, table)
          except Exception as e:
              logger.warning(f"Progress calculation failed: {e}")
  ```

**Day 2: Progress Triggers and Helper Functions**
- [ ] **Add progress calculation triggers** throughout the API:
  ```python
  def update_goal_progress(goal_id: str, progress_data: GoalProgressResponse, table):
      """Update goal with progress data in DynamoDB"""
      try:
          table.update_item(
              Key={"PK": f"USER#{progress_data.goal_id.split('#')[1]}", "SK": f"GOAL#{goal_id}"},
              UpdateExpression="SET progress = :progress, milestones = :milestones, completedTasks = :completed, totalTasks = :total, updatedAt = :updatedAt",
              ExpressionAttributeValues={
                  ":progress": progress_data.progress_percentage,
                  ":milestones": [m.dict() for m in progress_data.milestones],
                  ":completed": progress_data.completed_tasks,
                  ":total": progress_data.total_tasks,
                  ":updatedAt": int(time.time() * 1000)
              }
          )
      except Exception as e:
          logger.error(f"Failed to update goal progress: {e}")
  
  def trigger_progress_recalculation(goal_id: str, user_id: str, table):
      """Trigger progress recalculation for a goal"""
      try:
          progress_data = compute_goal_progress(goal_id, user_id, table)
          update_goal_progress(goal_id, progress_data, table)
      except Exception as e:
          logger.error(f"Progress recalculation failed: {e}")
  ```
- [ ] **Add progress calculation to goal creation**:
  ```python
  @app.post("/quests", response_model=GoalResponse, status_code=201)
  async def create_goal(payload: GoalCreatePayload, ...):
      # ... existing goal creation logic ...
      
      # Initialize progress data for new goal
      try:
          progress_data = GoalProgressResponse(
              goal_id=item['id'],
              progress_percentage=0.0,
              task_progress=0.0,
              time_progress=0.0,
              completed_tasks=0,
              total_tasks=0,
              milestones=[],
              last_updated=int(time.time() * 1000),
              is_overdue=False,
              is_urgent=False
          )
          update_goal_progress(item['id'], progress_data, table)
      except Exception as e:
          logger.warning(f"Initial progress setup failed: {e}")
  ```

#### 1.4 Backend Unit Tests
**Duration:** 3 days
**Dependencies:** 1.3
**Tasks:**

**Day 1: Progress Calculation Tests**
- [ ] **Create `backend/services/quest-service/tests/test_progress.py`** with comprehensive test coverage:
  ```python
  import pytest
  from datetime import datetime, timedelta
  from app.progress import compute_goal_progress, calculate_time_progress, calculate_milestones
  
  class TestProgressCalculation:
      def test_compute_goal_progress_no_tasks(self):
          """Test progress calculation with no tasks"""
          
      def test_compute_goal_progress_all_completed(self):
          """Test progress calculation with all tasks completed"""
          
      def test_compute_goal_progress_mixed_status(self):
          """Test progress calculation with mixed task statuses"""
          
      def test_compute_goal_progress_overdue_goal(self):
          """Test progress calculation for overdue goals"""
          
      def test_compute_goal_progress_urgent_goal(self):
          """Test progress calculation for urgent goals (7 days or less)"""
          
      def test_calculate_time_progress_normal_case(self):
          """Test time progress calculation with normal date ranges"""
          
      def test_calculate_time_progress_no_deadline(self):
          """Test time progress calculation with no deadline"""
          
      def test_calculate_time_progress_overdue(self):
          """Test time progress calculation for overdue goals"""
          
      def test_calculate_milestones_25_percent(self):
          """Test milestone calculation at 25% progress"""
          
      def test_calculate_milestones_50_percent(self):
          """Test milestone calculation at 50% progress"""
          
      def test_calculate_milestones_75_percent(self):
          """Test milestone calculation at 75% progress"""
          
      def test_calculate_milestones_100_percent(self):
          """Test milestone calculation at 100% progress"""
          
      def test_hybrid_progress_calculation(self):
          """Test hybrid progress calculation (70% task + 30% time)"""
          
      def test_progress_calculation_edge_cases(self):
          """Test edge cases: zero tasks, negative dates, etc."""
  ```

**Day 2: Integration Tests**
- [ ] **Update `backend/services/quest-service/tests/test_goals.py`** with progress integration tests:
  ```python
  def test_create_goal_includes_progress_data(self):
      """Test that goal creation includes initial progress data"""
      
  def test_update_task_triggers_progress_recalculation(self):
      """Test that task updates trigger progress recalculation"""
      
  def test_update_goal_deadline_triggers_progress_recalculation(self):
      """Test that goal deadline updates trigger progress recalculation"""
      
  def test_progress_calculation_accuracy(self):
      """Test that progress calculations are accurate"""
      
  def test_progress_data_persistence(self):
      """Test that progress data is properly stored in DynamoDB"""
  ```

**Day 3: Test Execution and Coverage**
- [ ] **Run comprehensive test suite**:
  ```bash
  # Run all tests with coverage
  pytest backend/services/quest-service/tests/ -v --cov=app --cov-report=html
  
  # Run specific progress tests
  pytest backend/services/quest-service/tests/test_progress.py -v
  
  # Run integration tests
  pytest backend/services/quest-service/tests/test_goals.py -v
  ```
- [ ] **Achieve >90% test coverage** for progress-related code
- [ ] **Fix any failing tests** and resolve issues
- [ ] **Document test cases** and expected behaviors

### Phase 1 Implementation Requirements

Based on the clarified requirements, the following specifications will be implemented:

#### 1. Progress Calculation Strategy
- **Weight Split**: Fixed 70/30 (task/time) globally - not configurable
- **Goals without tasks**: Show 0% progress (not time-based fallback)
- **Goals without deadline**: Not applicable - deadline is mandatory for all goals

#### 2. Milestone Configuration
- **Thresholds**: Fixed at 25%, 50%, 75%, 100% - not configurable
- **Names**: Standard milestone names (First Quarter, Halfway Point, Three Quarters, Complete)
- **Retroactive**: No - milestones only show current progress level, display milestone markers in progress bar

#### 3. Performance and Caching
- **Caching**: No caching implemented initially
- **Calculation**: Pre-calculate and store progress data in Goal record
- **Triggers**: Recalculate on task completion, addition, or deletion
- **Error Handling**: Continue API operation without progress data, log errors to CloudWatch

#### 4. Data Storage
- **Primary Storage**: Progress data stored directly in Goal record in DynamoDB
- **Migration**: Ignore existing goals - no migration required
- **Historical Data**: Store in separate analytics table for future use

#### 5. Error Handling
- **Goal Deletion**: Delete tasks and goal in transaction - maintain referential integrity
- **Invalid Data**: Recalculate progress when invalid/corrupted data detected
- **Error Logging**: Log all progress calculation errors to CloudWatch

#### 6. Integration Points
- **Recalculation**: Asynchronous progress updates
- **Triggers**: Only on task operations (create/update/delete) and goal deadline changes
- **Batch Updates**: Wait for all task updates to complete before recalculating progress

### Phase 2: AppSync Integration (Week 3)

#### 2.1 AppSync Resolvers
**Duration:** 4 days
**Dependencies:** 1.1
**Tasks:**
- [ ] Create `backend/infra/terraform2/resolvers/goalProgress.js`
  - Implement VTL resolver for `goalProgress` query
  - Query DynamoDB for goal and tasks
  - Calculate hybrid progress (70% task + 30% time)
  - Return comprehensive progress data
- [ ] Create `backend/infra/terraform2/resolvers/myGoalsProgress.js`
  - Implement VTL resolver for `myGoalsProgress` query
  - Query all user goals with progress data
  - Calculate progress for each goal
  - Return array of progress data
- [ ] Update `backend/infra/terraform2/resolvers/goal.js`
  - Add progress calculation to existing goal resolver
  - Include progress and milestones in goal response
  - Maintain backward compatibility

#### 2.2 AppSync Testing
**Duration:** 2 days
**Dependencies:** 2.1
**Tasks:**
- [ ] Test AppSync resolvers in development
- [ ] Verify GraphQL queries return correct data
- [ ] Test error handling in resolvers
- [ ] Validate progress calculation accuracy
- [ ] Test with various goal and task scenarios

### Phase 3: Frontend Integration (Week 4-5)

#### 3.1 Frontend API Layer
**Duration:** 3 days
**Dependencies:** 2.2
**Tasks:**
- [ ] Update `frontend/src/lib/apiGoal.ts`
  - Add `loadGoalsWithProgress()` function
  - Update `loadDashboardGoals()` to use backend progress
  - Add `getGoalProgress(goalId: string)` function
  - Add `getAllGoalsProgress()` function
  - Update GraphQL queries to include progress fields
- [ ] Update `frontend/src/lib/goalProgress.ts`
  - Add `calculateTaskProgress()` function
  - Update `GoalProgressData` interface with backend fields
  - Add `ProgressWithMilestones` interface
  - Update `sortGoals()` to support task-based progress
  - Add `formatMilestoneText()` utility function

#### 3.2 Dashboard Components
**Duration:** 4 days
**Dependencies:** 3.1
**Tasks:**
- [ ] Update `frontend/src/components/dashboard/GoalsButton.tsx`
  - Replace time-based progress with hybrid progress
  - Add dual progress bars (overall + task/time breakdown)
  - Add milestone display in goal cards
  - Add progress metrics summary
  - Update progress bar colors and styling
- [ ] Update `frontend/src/components/dashboards/UserDashboard.tsx`
  - Add progress metrics cards
  - Update stats overview with task-based data
  - Add progress trends display
  - Integrate with new progress calculation

#### 3.3 Internationalization
**Duration:** 2 days
**Dependencies:** 3.2
**Tasks:**
- [ ] Update `frontend/src/i18n/goalDashboard.ts`
  - Add milestone-related translations
  - Add progress metrics translations
  - Add task completion status translations
  - Add dual progress bar labels
- [ ] Test translations in all supported languages (EN, ES, FR)

#### 3.4 Frontend Testing
**Duration:** 3 days
**Dependencies:** 3.3
**Tasks:**
- [ ] Update `frontend/src/components/dashboard/__tests__/GoalsButton.test.tsx`
  - Add tests for backend progress integration
  - Test milestone display functionality
  - Test progress metrics calculation
  - Test task-based progress sorting
- [ ] Create `frontend/src/lib/__tests__/goalProgress.test.ts`
  - Test task-based progress calculation
  - Test milestone formatting functions
  - Test progress data transformation
  - Test sorting with backend progress data
- [ ] Run frontend test suite
- [ ] Fix any failing tests

### Phase 4: Integration Testing (Week 6)

#### 4.1 End-to-End Testing
**Duration:** 3 days
**Dependencies:** 3.4
**Tasks:**
- [ ] Create `tests/integration/goalProgressTest.js`
  - Test goal progress visualization
  - Test progress bar updates when tasks are completed
  - Test milestone display functionality
  - Test progress calculation accuracy
  - Test dual progress bar functionality
- [ ] Create `scripts/run-goal-progress-tests.ps1`
  - PowerShell script for automated testing
  - Test data setup and cleanup
  - Progress validation checks
  - Integration with existing test suite

#### 4.2 Performance Testing
**Duration:** 2 days
**Dependencies:** 4.1
**Tasks:**
- [ ] Test progress calculation performance
  - Measure response times for progress queries
  - Test with goals containing many tasks
  - Optimize database queries if needed
- [ ] Test dashboard performance
  - Measure loading times with progress data
  - Test with multiple goals and tasks
  - Optimize frontend rendering if needed

### Phase 5: Deployment and Monitoring (Week 7)

#### 5.1 Development Deployment
**Duration:** 2 days
**Dependencies:** 4.2
**Tasks:**
- [ ] Deploy backend changes to development
  - Deploy updated Lambda functions
  - Deploy AppSync schema changes
  - Deploy resolver updates
- [ ] Deploy frontend changes to development
  - Build and deploy updated frontend
  - Test in development environment
  - Verify all functionality works

#### 5.2 Staging Deployment and UAT
**Duration:** 3 days
**Dependencies:** 5.1
**Tasks:**
- [ ] Deploy to staging environment
- [ ] Run full test suite in staging
- [ ] Perform user acceptance testing
  - Test progress calculation accuracy
  - Test dashboard display
  - Test milestone functionality
  - Test performance under load
- [ ] Fix any issues found during UAT

#### 5.3 Production Deployment
**Duration:** 2 days
**Dependencies:** 5.2
**Tasks:**
- [ ] Deploy to production environment
- [ ] Monitor deployment health
- [ ] Verify all functionality in production
- [ ] Set up monitoring and alerting
- [ ] Document deployment process

### Phase 6: Post-Deployment (Week 8)

#### 6.1 Monitoring and Optimization
**Duration:** 3 days
**Dependencies:** 5.3
**Tasks:**
- [ ] Monitor progress calculation performance
- [ ] Track error rates and response times
- [ ] Monitor milestone achievement rates
- [ ] Optimize based on real-world usage
- [ ] Collect user feedback

#### 6.2 Documentation and Training
**Duration:** 2 days
**Dependencies:** 6.1
**Tasks:**
- [ ] Update API documentation
- [ ] Update user documentation
- [ ] Create progress calculation guide
- [ ] Document configuration options
- [ ] Train support team on new features

## Implementation Dependencies

### Critical Path
1. **Database Schema** â†’ **Backend Models** â†’ **Backend API** â†’ **AppSync Resolvers**
2. **AppSync Resolvers** â†’ **Frontend API** â†’ **Dashboard Components** â†’ **Testing**
3. **Testing** â†’ **Deployment** â†’ **Monitoring**

### Parallel Workstreams
- **Backend Development** and **Frontend Preparation** can run in parallel after Phase 1.1
- **Unit Testing** can run in parallel with **API Integration**
- **Frontend Testing** can run in parallel with **Integration Testing**

### Risk Mitigation
- **Early Testing**: Start testing as soon as each component is complete
- **Incremental Deployment**: Deploy and test each phase before moving to the next
- **Rollback Plan**: Maintain ability to rollback each deployment
- **Performance Monitoring**: Monitor performance throughout implementation

## Success Metrics

### Development Metrics
- [ ] All unit tests passing (>90% coverage)
- [ ] All integration tests passing
- [ ] Performance targets met (<100ms progress calculation)
- [ ] No critical bugs in staging

### User Experience Metrics
- [ ] Dashboard loads within 2 seconds
- [ ] Progress updates in real-time
- [ ] Milestone notifications working
- [ ] Dual progress bars displaying correctly

### Business Metrics
- [ ] User engagement with progress features
- [ ] Goal completion rates
- [ ] User satisfaction with progress tracking
- [ ] Support ticket reduction

## Dependencies

### Internal Dependencies
- Task 15.5 (Mark task as complete) - âœ… Completed
- Existing goal and task CRUD operations
- Authentication and authorization system
- DynamoDB single-table design

### External Dependencies
- FastAPI framework
- DynamoDB service
- JWT token validation
- Pydantic for data validation

## Risk Assessment

### High Risk
- **Performance impact:** Progress calculation on goals with many tasks
- **Mitigation:** Implement caching and query optimization

### Medium Risk
- **Data consistency:** Progress updates when tasks change
- **Mitigation:** Implement atomic operations and proper error handling

### Low Risk
- **API compatibility:** Changes to existing endpoints
- **Mitigation:** Maintain backward compatibility with optional fields

## Future Enhancements

### Phase 2 Features
- Progress trends and analytics
- Custom milestone definitions
- Progress notifications and alerts
- Progress sharing and collaboration

### Performance Optimizations
- Redis caching for progress data
- Background progress calculation
- Batch progress updates
- Progress precomputation for popular goals

This technical plan provides a comprehensive roadmap for implementing goal progress computation in the backend, following the existing architecture patterns and ensuring robust, scalable, and maintainable code.
