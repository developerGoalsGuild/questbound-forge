# ---------------------------------------
# schema.graphql  (AppSync-compatible)
# ---------------------------------------

# AWS Scalars
scalar AWSDateTime
scalar AWSDate
scalar AWSTimestamp
scalar AWSJSON

# Enums
enum GoalStatus {
  active
  paused
  completed
  archived
}

enum TaskStatus {
  open
  in_progress
  done
  canceled
}

# Types
type User {
  id: ID!
  email: String
  fullName: String
  nickname: String
  birthDate: AWSDate
  status: String
  country: String
  language: String
  pronouns: String
  bio: String
  tags: [String!]!
  tier: String!                 # "free" | "premium" etc.
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

type Goal {
  id: ID!
  userId: ID!
  title: String!
  description: String
  tags: [String!]
  status: GoalStatus!
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

type Task {
  id: ID!
  goalId: ID!
  ownerId: ID!
  title: String!
  nlpPlan: AWSJSON
  dueAt: AWSTimestamp          # stored as epoch seconds; if you use ms, convert at resolver
  status: TaskStatus!
  assignees: [ID!]
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}

type Message {
  id: ID!
  roomId: ID!
  senderId: ID!
  text: String!
  ts: AWSTimestamp!
}

type Offer {
  id: ID!
  title: String!
  url: String!
  tags: [String!]
  validTo: AWSDateTime
}

# Queries
type Query {
  me: User
  user(userId: ID!): User
  goals(userId: ID!): [Goal!]!
  tasks(goalId: ID!): [Task!]!
  messages(roomId: ID!, after: AWSTimestamp, limit: Int = 50): [Message!]!
  offers(tags: [String!], limit: Int = 20): [Offer!]!
  isEmailAvailable(email: String!): Boolean!
}

# Mutations
type Mutation {
  """
  Create a user profile. Accepts a bcrypt password hash (NEVER plaintext).
  The resolver sets tier to 'free' by default.
  """
  createUser(input: CreateUserInput!): User!

  """
  Create a goal for the current user (from JWT).
  """
  createGoal(input: GoalInput!): Goal!

  """
  Add a task under a goal owned by the current user.
  """
  addTask(input: TaskInput!): Task!

  """
  Post a message to a chat room.
  """
  sendMessage(roomId: ID!, text: String!): Message!
}

# Subscriptions
type Subscription {
  """
  Subscribe to new messages for a room. Requires the same roomId as in sendMessage.
  """
  onMessage(roomId: ID!): Message!
    @aws_subscribe(mutations: ["sendMessage"])
}

# Inputs
input CreateUserInput {
  email: String!
  fullName: String!
  nickname: String!
  birthDate: AWSDate
  status: String
  country: String!
  language: String = "en"
  pronouns: String
  bio: String
  tags: [String!]
  passwordHash: String       # bcrypt hash; hashing is done outside this API
  password: String           # DEV ONLY: plaintext accepted for non-production
}

input GoalInput {
  title: String!
  description: String
  tags: [String!]
}

input TaskInput {
  goalId: ID!
  title: String!
  # If you store epoch milliseconds internally, convert to seconds or adjust resolver to return seconds.
  dueAt: AWSTimestamp
  nlpPlan: AWSJSON
  assignees: [ID!]
}
