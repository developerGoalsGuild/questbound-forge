# GoalsGuild Terraform Infrastructure - Cursor Rules

## Infrastructure as Code Standards

### 1. Module Organization
- **ORGANIZE** modules by functionality (lambda, apigateway, security, etc.)
- **USE** consistent naming conventions across all modules
- **INCLUDE** proper variable and output definitions
- **MAINTAIN** clear module interfaces

```
modules/
├── lambda/                 # Lambda function module
├── apigateway/            # API Gateway module
├── security/              # Security and IAM module
├── docker_lambda_image/   # Docker image build module
└── vpc/                   # VPC and networking module
```

### 2. Stack Organization
- **ORGANIZE** stacks by environment and service
- **SEPARATE** concerns: services, networking, security
- **USE** consistent directory structure
- **INCLUDE** proper variable files

```
stacks/
├── services/
│   ├── user-service/
│   ├── quest-service/
│   └── authorizer-service/
├── networking/
├── security/
└── apigateway/
```

### 3. Variable Management
- **DEFINE** all variables with proper types and descriptions
- **USE** consistent naming conventions
- **INCLUDE** default values where appropriate
- **VALIDATE** variable values

```hcl
# ✅ GOOD: Well-defined variables
variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be one of: dev, staging, prod."
  }
}

variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "us-east-2"
}

variable "memory_size" {
  description = "Lambda function memory size in MB"
  type        = number
  default     = 512
  validation {
    condition     = var.memory_size >= 128 && var.memory_size <= 10240
    error_message = "Memory size must be between 128 and 10240 MB."
  }
}
```

## Lambda Function Configuration

### 4. Lambda Module Standards
- **USE** consistent Lambda function configuration
- **INCLUDE** proper IAM role and permissions
- **CONFIGURE** CloudWatch logging
- **SET** appropriate timeout and memory values

```hcl
# ✅ GOOD: Lambda module configuration
resource "aws_lambda_function" "this" {
  function_name = var.function_name
  image_uri     = var.image_uri
  role          = var.role_arn
  timeout       = var.timeout
  memory_size   = var.memory_size
  package_type  = "Image"
  
  environment {
    variables = merge(var.environment_variables, {
      ENVIRONMENT = var.environment
    })
  }
  
  tracing_config {
    mode = "PassThrough"
  }
  
  tags = {
    Project     = "goalsguild"
    Environment = var.environment
  }
}

resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/${var.function_name}"
  retention_in_days = 14
  
  tags = {
    Project     = "goalsguild"
    Environment = var.environment
  }
}
```

### 5. Simplified Deployment Pattern
- **PREFER** referencing existing ECR images over building in Terraform
- **USE** local variables for image URIs
- **AVOID** complex Docker build modules when possible
- **MAINTAIN** simple, reliable deployment process

```hcl
# ✅ GOOD: Simplified deployment pattern
locals {
  existing_image_uri = "ACCOUNT.dkr.ecr.REGION.amazonaws.com/SERVICE_NAME:VERSION"
}

module "service_lambda" {
  source        = "../../../modules/lambda"
  function_name = "goalsguild_SERVICE_NAME"
  image_uri     = local.existing_image_uri
  role_arn      = data.terraform_remote_state.security.outputs.lambda_exec_role_arn
  timeout       = 10
  memory_size   = 512
  environment   = var.environment
  environment_variables = {
    ENVIRONMENT         = var.environment
    SETTINGS_SSM_PREFIX = "/goalsguild/SERVICE_NAME/"
  }
}
```

## API Gateway Configuration

### 6. API Gateway Module Standards
- **DEFINE** clear resource hierarchy
- **INCLUDE** proper CORS configuration
- **IMPLEMENT** custom authorizers for authentication
- **CONFIGURE** Lambda integrations correctly

```hcl
# ✅ GOOD: API Gateway resource configuration
resource "aws_api_gateway_resource" "profile" {
  rest_api_id = aws_api_gateway_rest_api.rest_api.id
  parent_id   = aws_api_gateway_rest_api.rest_api.root_resource_id
  path_part   = "profile"
}

resource "aws_api_gateway_method" "profile_get" {
  rest_api_id      = aws_api_gateway_rest_api.rest_api.id
  resource_id      = aws_api_gateway_resource.profile.id
  http_method      = "GET"
  authorization    = "CUSTOM"
  authorizer_id    = aws_api_gateway_authorizer.lambda_authorizer.id
  api_key_required = true
}

resource "aws_api_gateway_method" "profile_put" {
  rest_api_id      = aws_api_gateway_rest_api.rest_api.id
  resource_id      = aws_api_gateway_resource.profile.id
  http_method      = "PUT"
  authorization    = "CUSTOM"
  authorizer_id    = aws_api_gateway_authorizer.lambda_authorizer.id
  api_key_required = true
}
```

### 7. CORS Configuration
- **INCLUDE** OPTIONS method for all resources
- **CONFIGURE** proper CORS headers
- **USE** local variables for CORS configuration
- **IMPLEMENT** consistent CORS policy

```hcl
# ✅ GOOD: CORS configuration
locals {
  cors_allow_origin  = "*"
  cors_allow_headers = "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token"
}

resource "aws_api_gateway_method" "profile_options" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  resource_id   = aws_api_gateway_resource.profile.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_method_response" "profile_options_response" {
  rest_api_id = aws_api_gateway_rest_api.rest_api.id
  resource_id = aws_api_gateway_resource.profile.id
  http_method = aws_api_gateway_method.profile_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration" "profile_options_integration" {
  rest_api_id = aws_api_gateway_rest_api.rest_api.id
  resource_id = aws_api_gateway_resource.profile.id
  http_method = aws_api_gateway_method.profile_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = jsonencode({
      statusCode = 200
    })
  }
}

resource "aws_api_gateway_integration_response" "profile_options_integration_response" {
  rest_api_id = aws_api_gateway_rest_api.rest_api.id
  resource_id = aws_api_gateway_resource.profile.id
  http_method = aws_api_gateway_method.profile_options.http_method
  status_code = aws_api_gateway_method_response.profile_options_response.status_code
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'${local.cors_allow_headers}'"
    "method.response.header.Access-Control-Allow-Methods" = "'GET,OPTIONS,POST,PUT,DELETE'"
    "method.response.header.Access-Control-Allow-Origin"  = "'${local.cors_allow_origin}'"
  }
}
```

## Security Configuration

### 8. IAM Role and Policy Management
- **CREATE** least-privilege IAM roles
- **SEPARATE** roles by function (lambda execution, API Gateway, etc.)
- **USE** managed policies where appropriate
- **INCLUDE** proper resource ARN patterns

```hcl
# ✅ GOOD: IAM role configuration
resource "aws_iam_role" "lambda_exec_role" {
  name = "goalsguild_lambda_exec_role_${var.environment}"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
  
  tags = {
    Project     = "goalsguild"
    Environment = var.environment
  }
}

resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

resource "aws_iam_role_policy" "lambda_dynamodb_access" {
  name = "lambda_dynamodb_access_${var.environment}"
  role = aws_iam_role.lambda_exec_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Query",
          "dynamodb:Scan"
        ]
        Resource = [
          var.core_table_arn,
          "${var.core_table_arn}/index/*"
        ]
      }
    ]
  })
}
```

### 9. API Gateway Security
- **IMPLEMENT** custom authorizers for authentication
- **CONFIGURE** API keys for additional security
- **USE** proper CORS policies
- **INCLUDE** request validation

```hcl
# ✅ GOOD: API Gateway authorizer
resource "aws_api_gateway_authorizer" "lambda_authorizer" {
  name                   = "lambda_authorizer"
  rest_api_id            = aws_api_gateway_rest_api.rest_api.id
  authorizer_uri         = aws_lambda_function.authorizer.invoke_arn
  authorizer_credentials = aws_iam_role.api_gateway_lambda_role.arn
  type                   = "TOKEN"
  identity_source        = "method.request.header.Authorization"
}

resource "aws_lambda_permission" "api_gateway_lambda" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.authorizer.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.rest_api.execution_arn}/*/*"
}
```

## Environment Management

### 10. Environment-Specific Configuration
- **USE** separate variable files for each environment
- **INCLUDE** environment-specific resource naming
- **CONFIGURE** appropriate resource sizes per environment
- **MAINTAIN** consistent tagging strategy

```hcl
# ✅ GOOD: Environment-specific configuration
locals {
  common_tags = {
    Project     = "goalsguild"
    Environment = var.environment
    ManagedBy   = "terraform"
  }
  
  resource_prefix = "goalsguild_${var.environment}"
}

resource "aws_lambda_function" "this" {
  function_name = "${local.resource_prefix}_${var.service_name}"
  
  tags = local.common_tags
}
```

### 11. Variable File Organization
- **CREATE** separate .tfvars files for each environment
- **INCLUDE** all necessary variables
- **USE** consistent variable naming
- **DOCUMENT** variable purposes

```hcl
# environments/dev.tfvars
environment = "dev"
aws_region  = "us-east-2"

# Lambda configuration
memory_size = 512
timeout     = 10

# Database configuration
core_table_name = "goalsguild_core_dev"
core_table_arn  = "arn:aws:dynamodb:us-east-2:ACCOUNT:table/goalsguild_core_dev"

# API Gateway configuration
api_gateway_stage = "dev"
```

## State Management

### 12. Remote State Configuration
- **USE** remote state for shared resources
- **CONFIGURE** proper state locking
- **INCLUDE** state encryption
- **MAINTAIN** state file organization

```hcl
# ✅ GOOD: Remote state configuration
data "terraform_remote_state" "security" {
  backend = "local"
  config = { path = "../../security/terraform.tfstate" }
}

data "terraform_remote_state" "networking" {
  backend = "local"
  config = { path = "../../networking/terraform.tfstate" }
}
```

### 13. Output Management
- **DEFINE** clear outputs for each module
- **INCLUDE** resource ARNs and names
- **DOCUMENT** output purposes
- **USE** consistent output naming

```hcl
# ✅ GOOD: Module outputs
output "function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.this.function_name
}

output "function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.this.arn
}

output "invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.this.invoke_arn
}
```

## Deployment and CI/CD

### 14. Deployment Scripts
- **CREATE** consistent deployment scripts
- **INCLUDE** proper error handling
- **USE** environment-specific configurations
- **IMPLEMENT** rollback capabilities

```powershell
# ✅ GOOD: Deployment script pattern
param(
  [ValidateSet("dev","staging","prod")] [string]$Env = "dev",
  [switch]$PlanOnly,
  [switch]$AutoApprove = $true,
  [switch]$SkipInit
)

$ErrorActionPreference = "Stop"

function Write-Log {
  param([string]$Message, [string]$Level = "INFO")
  $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
  $LogEntry = "[$Timestamp] [$Level] [SERVICE_NAME] $Message"
  Microsoft.PowerShell.Utility\Write-Host $LogEntry
}

try {
  if (-not $SkipInit) {
    Write-Log "Running terraform init"
    terraform init -upgrade
  }
  
  if ($PlanOnly) {
    Write-Log "Running terraform plan"
    terraform plan -var-file "../../environments/$Env.tfvars"
  } else {
    Write-Log "Running terraform apply"
    terraform apply -var-file "../../environments/$Env.tfvars" -auto-approve
  }
  
  Write-Log "Deployment completed successfully"
} catch {
  Write-Log "Deployment failed: $($_.Exception.Message)" "ERROR"
  throw
}
```

### 15. Resource Dependencies
- **DEFINE** proper resource dependencies
- **USE** depends_on when necessary
- **AVOID** circular dependencies
- **INCLUDE** proper resource ordering

```hcl
# ✅ GOOD: Resource dependencies
resource "aws_lambda_function" "this" {
  # ... configuration
  depends_on = [aws_cloudwatch_log_group.lambda_logs]
}

resource "aws_api_gateway_integration" "this" {
  # ... configuration
  depends_on = [aws_lambda_function.this]
}
```

## Monitoring and Logging

### 16. CloudWatch Configuration
- **CONFIGURE** appropriate log retention
- **INCLUDE** log group tags
- **SET** proper log group names
- **IMPLEMENT** log filtering when needed

```hcl
# ✅ GOOD: CloudWatch log group configuration
resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/${var.function_name}"
  retention_in_days = var.log_retention_days
  
  tags = {
    Project     = "goalsguild"
    Environment = var.environment
    Service     = var.service_name
  }
}
```

### 17. Resource Tagging
- **IMPLEMENT** consistent tagging strategy
- **INCLUDE** required tags for all resources
- **USE** local variables for common tags
- **MAINTAIN** tag consistency across environments

```hcl
# ✅ GOOD: Consistent tagging
locals {
  common_tags = {
    Project     = "goalsguild"
    Environment = var.environment
    Service     = var.service_name
    ManagedBy   = "terraform"
    CreatedBy   = "terraform"
  }
}

resource "aws_lambda_function" "this" {
  # ... configuration
  
  tags = local.common_tags
}
```

## Best Practices Summary

### 18. Code Quality
- **USE** consistent formatting and naming
- **INCLUDE** proper comments and documentation
- **VALIDATE** all variable inputs
- **MAINTAIN** clear module interfaces

### 19. Security
- **IMPLEMENT** least-privilege access
- **USE** proper encryption
- **CONFIGURE** secure defaults
- **INCLUDE** proper authentication

### 20. Reliability
- **DESIGN** for failure and recovery
- **IMPLEMENT** proper error handling
- **INCLUDE** monitoring and alerting
- **MAINTAIN** backup and disaster recovery

Remember: **Simplicity and consistency** - Follow the established patterns and keep configurations simple and maintainable.
