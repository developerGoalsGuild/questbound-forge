# GoalsGuild QuestBound Forge - Cursor Rules Summary

## üìã **Rule Files Overview**

This project now has comprehensive Cursor rules organized by domain:

### 1. **`.cursorrules`** - Main Rules
- AppSync GraphQL integration rules
- Schema-frontend synchronization
- Resolver data mapping
- Frontend error handling
- Environment configuration
- Deployment checklist

### 2. **`.cursorrules-backend`** - Backend Development
- AppSync resolver development patterns
- DynamoDB key patterns
- Error handling standards
- Logging requirements
- Terraform infrastructure
- Python backend services

### 3. **`.cursorrules-frontend`** - Frontend Development
- React component structure
- Safe property access patterns
- Error handling and loading states
- GraphQL integration
- State management
- Internationalization
- Performance optimization

### 4. **`.cursorrules-debugging`** - Debugging Workflow
- AppSync debugging procedures
- Frontend debugging techniques
- Common error patterns
- CloudWatch log analysis
- Database debugging
- Performance debugging

### 5. **`.cursorrules-testing`** - Testing Standards
- Unit testing patterns
- Integration testing
- End-to-end testing
- Test data management
- Coverage requirements
- Testing best practices

### 6. **`.cursorrules-deployment`** - Deployment Procedures
- Pre-deployment checklist
- Backend deployment steps
- Frontend deployment process
- Post-deployment verification
- Rollback procedures
- Monitoring and alerting

## üéØ **Key Principles**

### **Schema-First Development**
1. **Always update GraphQL schema first**
2. **Then update resolver code**
3. **Then update frontend query**
4. **Finally update TypeScript interfaces**
5. **Deploy and test complete flow**

### **Safe Property Access**
```typescript
// ‚úÖ ALWAYS use safe access
const value = obj?.property?.method() || 'default';

// ‚ùå NEVER assume properties exist
const value = obj.property.method();
```

### **Comprehensive Error Handling**
```typescript
// ‚úÖ ALWAYS handle all error cases
try {
  const result = await apiCall();
  return result;
} catch (error) {
  console.error('Error details:', error);
  
  if (error?.message === 'SPECIFIC_ERROR') {
    // Handle specific error
    return handleSpecificError();
  }
  
  // Handle generic error
  throw new Error('Operation failed');
}
```

### **Extensive Logging**
```javascript
// ‚úÖ ALWAYS log resolver execution
export function response(ctx) {
  console.log('[resolverName] Response context:', JSON.stringify(ctx, null, 2));
  console.log('[resolverName] Data:', JSON.stringify(data, null, 2));
  // ... rest of function
}
```

## üöÄ **Quick Reference**

### **Before Making Changes**
1. Read relevant rule file
2. Check existing patterns
3. Plan the complete flow
4. Test in isolation first

### **During Development**
1. Follow established patterns
2. Add comprehensive logging
3. Handle all error cases
4. Use safe property access
5. Test frequently

### **Before Deployment**
1. Run all tests
2. Check schema consistency
3. Verify environment variables
4. Test complete flow
5. Check CloudWatch logs

### **After Deployment**
1. Verify all services are healthy
2. Test critical user flows
3. Monitor logs for errors
4. Check performance metrics
5. Update documentation

## üîß **Common Patterns**

### **GraphQL Resolver**
```javascript
export function request(ctx) {
  console.log('[resolver] Request:', JSON.stringify(ctx, null, 2));
  const sub = ctx.identity?.resolverContext?.sub || ctx.identity?.sub;
  if (!sub) util.unauthorized();
  // ... rest of request logic
}

export function response(ctx) {
  console.log('[resolver] Response:', JSON.stringify(ctx, null, 2));
  if (ctx.error) util.error(ctx.error.message, ctx.error.type);
  const data = ctx.result?.item || ctx.result;
  if (!data) util.error('Data not found', 'NotFound');
  // ... rest of response logic
}
```

### **React Component**
```typescript
const Component: React.FC<Props> = ({ prop1, prop2 }) => {
  const { t } = useTranslation();
  const { data, loading, error, refetch } = useCustomHook();
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      <h1>{data?.title || 'Default Title'}</h1>
      {/* Safe property access throughout */}
    </div>
  );
};
```

### **API Function**
```typescript
export async function apiCall(): Promise<ResponseType> {
  try {
    const response = await fetch(endpoint, options);
    const data = await response.json();
    
    if (!response.ok || data.errors?.length) {
      throw new Error('API error');
    }
    
    return data;
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}
```

## üìö **Learning from Past Issues**

### **The Profile Role Issue (2025-01-30)**
- **Problem**: Frontend expected `role` field that wasn't in GraphQL schema
- **Root Cause**: Schema-frontend mismatch
- **Solution**: Added `role` to schema, query, and resolver
- **Prevention**: Schema-first development approach

### **The Property Access Issue**
- **Problem**: `Cannot read properties of undefined (reading 'charAt')`
- **Root Cause**: Unsafe property access
- **Solution**: Used optional chaining (`?.`)
- **Prevention**: Always use safe property access

### **The Resolver Logging Issue**
- **Problem**: No CloudWatch logs for debugging
- **Root Cause**: Logging not enabled in AppSync
- **Solution**: Enabled CloudWatch logging in Terraform
- **Prevention**: Always enable logging during development

## üéâ **Success Metrics**

### **Code Quality**
- ‚úÖ 100% test coverage for critical functions
- ‚úÖ All components handle loading/error states
- ‚úÖ All API calls have proper error handling
- ‚úÖ All resolvers have comprehensive logging

### **Developer Experience**
- ‚úÖ Clear error messages for debugging
- ‚úÖ Consistent patterns across codebase
- ‚úÖ Comprehensive documentation
- ‚úÖ Automated testing and deployment

### **User Experience**
- ‚úÖ Graceful error handling
- ‚úÖ Loading states for all async operations
- ‚úÖ Internationalization support
- ‚úÖ Responsive design

Remember: **These rules are living documents!** Update them as you learn new patterns and encounter new challenges. The goal is to prevent issues before they happen and make development more efficient and enjoyable! üöÄ
