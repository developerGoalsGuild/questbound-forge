name: CI/CD Components

on:
  push:
    branches:
      - dev
      - staging
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (dev, staging, prod). Optional for dispatch."
        required: false
        type: choice
        options:
          - dev
          - staging
          - prod

permissions:
  contents: read
  id-token: write

concurrency:
  group: cicd-components-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-context.outputs.environment }}
      role_arn: ${{ steps.set-context.outputs.role_arn }}
      should_run: ${{ steps.set-context.outputs.should_run }}
    steps:
      - id: set-context
        name: Resolve environment and role
        shell: bash
        run: |
          env_input="${{ inputs.environment }}"
          if [ -n "$env_input" ]; then
            env="$env_input"
          else
            case "${GITHUB_REF_NAME}" in
              dev) env="dev" ;;
              staging) env="staging" ;;
              main|master) env="prod" ;;
              *) env="" ;;
            esac
          fi

          if [ -z "$env" ]; then
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          case "$env" in
            dev) role="${{ secrets.AWS_ROLE_ARN_DEV }}" ;;
            staging) role="${{ secrets.AWS_ROLE_ARN_STAGING }}" ;;
            prod) role="${{ secrets.AWS_ROLE_ARN_PROD }}" ;;
          esac

          echo "environment=$env" >> "$GITHUB_OUTPUT"
          echo "role_arn=$role" >> "$GITHUB_OUTPUT"
          echo "should_run=true" >> "$GITHUB_OUTPUT"

  changes:
    runs-on: ubuntu-latest
    needs: context
    if: needs.context.outputs.should_run == 'true'
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      landing: ${{ steps.filter.outputs.landing }}
      infra: ${{ steps.filter.outputs.infra }}
      services: ${{ steps.filter.outputs.services }}
      authorizer_service: ${{ steps.filter.outputs.authorizer_service }}
      connect_service: ${{ steps.filter.outputs.connect_service }}
      services_matrix: ${{ steps.set-services.outputs.matrix }}
      services_has_changes: ${{ steps.set-services.outputs.has_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - id: filter
        name: Detect changed components
        uses: dorny/paths-filter@v3
        with:
          filters: |
            frontend:
              - "apps/frontend/**"
            landing:
              - "apps/landing-page/**"
            infra:
              - "backend/infra/terraform2/**"
            services:
              - "backend/services/**"
            user_service:
              - "backend/services/user-service/**"
            quest_service:
              - "backend/services/quest-service/**"
            subscription_service:
              - "backend/services/subscription-service/**"
            collaboration_service:
              - "backend/services/collaboration-service/**"
            guild_service:
              - "backend/services/guild-service/**"
            messaging_service:
              - "backend/services/messaging-service/**"
            gamification_service:
              - "backend/services/gamification-service/**"
            authorizer_service:
              - "backend/services/authorizer-service/**"
            connect_service:
              - "backend/services/connect-service/**"

      - id: set-services
        name: Build service matrix
        shell: bash
        run: |
          services=()
          if [[ "${{ steps.filter.outputs.user_service }}" == "true" ]]; then services+=("user-service"); fi
          if [[ "${{ steps.filter.outputs.quest_service }}" == "true" ]]; then services+=("quest-service"); fi
          if [[ "${{ steps.filter.outputs.subscription_service }}" == "true" ]]; then services+=("subscription-service"); fi
          if [[ "${{ steps.filter.outputs.collaboration_service }}" == "true" ]]; then services+=("collaboration-service"); fi
          if [[ "${{ steps.filter.outputs.guild_service }}" == "true" ]]; then services+=("guild-service"); fi
          if [[ "${{ steps.filter.outputs.messaging_service }}" == "true" ]]; then services+=("messaging-service"); fi
          if [[ "${{ steps.filter.outputs.gamification_service }}" == "true" ]]; then services+=("gamification-service"); fi

          if [ ${#services[@]} -eq 0 ]; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "matrix={\"service\":[]}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          json=$(printf '%s\n' "${services[@]}" | jq -R . | jq -s '{service: .}')
          echo "has_changes=true" >> "$GITHUB_OUTPUT"
          echo "matrix=$json" >> "$GITHUB_OUTPUT"

  frontend:
    runs-on: ubuntu-latest
    needs: [context, changes]
    if: needs.changes.outputs.frontend == 'true'
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.context.outputs.role_arn }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: apps/frontend/package.json

      - name: Install dependencies
        working-directory: apps/frontend
        run: npm install

      - name: Run unit tests
        working-directory: apps/frontend
        run: npm run test:ci

      # - name: Start dev server
      #   working-directory: apps/frontend
      #   run: |
      #     npm run dev -- --host 127.0.0.1 --port 5173 > /tmp/vite.log 2>&1 &
      #     echo $! > /tmp/vite.pid
      #
      # - name: Wait for dev server
      #   working-directory: apps/frontend
      #   run: npx wait-on http://127.0.0.1:5173
      #
      # - name: Run Selenium integration tests
      #   working-directory: apps/frontend
      #   env:
      #     TEST_USER_EMAIL: ${{ secrets.TEST_USER_EMAIL }}
      #     TEST_USER_PASSWORD: ${{ secrets.TEST_USER_PASSWORD }}
      #     VITE_APP_URL: http://127.0.0.1:5173
      #   run: npm run test:selenium:comprehensive:verbose
      #
      # - name: Stop dev server
      #   if: always()
      #   run: |
      #     if [ -f /tmp/vite.pid ]; then
      #       kill "$(cat /tmp/vite.pid)" || true
      #     fi

      - name: Build frontend
        working-directory: apps/frontend
        run: |
          case "${{ needs.context.outputs.environment }}" in
            dev) mode="development" ;;
            staging) mode="staging" ;;
            prod) mode="production" ;;
          esac
          npm run build -- --mode "$mode"

      - id: frontend-vars
        name: Resolve frontend variables
        shell: bash
        run: |
          env="${{ needs.context.outputs.environment }}"
          if [ "$env" = "prod" ]; then
            echo "extra_vars=-var=custom_domain=goals.guild.com -var='additional_domains=[\"www.goals.guild.com\"]' -var=ssl_certificate_arn=${{ secrets.FRONTEND_ACM_CERT_ARN_PROD }} -var=use_route53=false -var=route53_zone_name=" >> "$GITHUB_OUTPUT"
          else
            echo "extra_vars=-var=custom_domain= -var='additional_domains=[]' -var=ssl_certificate_arn= -var=use_route53=false -var=route53_zone_name=" >> "$GITHUB_OUTPUT"
          fi

      - name: Terraform apply (frontend)
        working-directory: apps/frontend/terraform
        env:
          AWS_REGION: us-east-1
          AWS_DEFAULT_REGION: us-east-1
        run: |
          terraform init -upgrade
          terraform apply -var-file="environments/${{ needs.context.outputs.environment }}.tfvars" ${{ steps.frontend-vars.outputs.extra_vars }} -auto-approve

      - name: Deploy frontend assets
        env:
          AWS_REGION: us-east-1
          AWS_DEFAULT_REGION: us-east-1
        run: |
          bucket=$(terraform -chdir=apps/frontend/terraform output -raw s3_bucket_name)
          distribution=$(terraform -chdir=apps/frontend/terraform output -raw cloudfront_distribution_id)
          if [ -z "$bucket" ] || [ -z "$distribution" ]; then
            echo "Missing frontend S3 bucket or CloudFront distribution for environment."
            exit 1
          fi

          aws s3 sync "apps/frontend/dist" "s3://$bucket/" --delete
          aws cloudfront create-invalidation --distribution-id "$distribution" --paths "/*"

  landing:
    runs-on: ubuntu-latest
    needs: [context, changes]
    if: needs.changes.outputs.landing == 'true'
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.context.outputs.role_arn }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - id: landing-vars
        name: Resolve landing page variables
        shell: bash
        run: |
          env="${{ needs.context.outputs.environment }}"
          if [ "$env" = "prod" ]; then
            echo "extra_vars=-var=custom_domain=goals.guild.com -var='additional_domains=[\"www.goals.guild.com\"]' -var=ssl_certificate_arn=${{ secrets.LANDING_PAGE_ACM_CERT_ARN_PROD }} -var=use_route53=false -var=route53_zone_name=" >> "$GITHUB_OUTPUT"
          else
            echo "extra_vars=-var=custom_domain= -var='additional_domains=[]' -var=ssl_certificate_arn= -var=use_route53=false -var=route53_zone_name=" >> "$GITHUB_OUTPUT"
          fi

      - name: Terraform apply (landing page)
        working-directory: apps/landing-page/terraform
        run: |
          terraform init -upgrade
          terraform apply -var-file="environments/${{ needs.context.outputs.environment }}.tfvars" ${{ steps.landing-vars.outputs.extra_vars }} -auto-approve

      - name: Upload landing page assets
        working-directory: apps/landing-page
        run: |
          bucket=$(terraform -chdir=terraform output -raw s3_bucket_name)
          distribution=$(terraform -chdir=terraform output -raw cloudfront_distribution_id)

          aws s3 sync "src" "s3://$bucket/" \
            --delete \
            --exclude "*.git*" \
            --exclude "*.DS_Store" \
            --exclude "Thumbs.db" \
            --cache-control "max-age=31536000" \
            --metadata-directive REPLACE

          aws s3 cp "src" "s3://$bucket/" \
            --recursive \
            --exclude "*" \
            --include "*.html" \
            --cache-control "max-age=3600" \
            --metadata-directive REPLACE

          aws cloudfront create-invalidation --distribution-id "$distribution" --paths "/*"

  infra:
    runs-on: ubuntu-latest
    needs: [context, changes]
    if: needs.changes.outputs.infra == 'true'
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.context.outputs.role_arn }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Deploy infrastructure stacks
        run: |
          chmod +x backend/infra/terraform2/scripts/deploy-all-with-build.sh
          backend/infra/terraform2/scripts/deploy-all-with-build.sh \
            --env "${{ needs.context.outputs.environment }}" \
            --infrastructure-only

  services:
    runs-on: ubuntu-latest
    needs: [context, changes, backend-tests]
    if: needs.changes.outputs.services_has_changes == 'true'
    strategy:
      matrix: ${{ fromJson(needs.changes.outputs.services_matrix) }}
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.context.outputs.role_arn }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy service
        shell: bash
        run: |
          case "${{ matrix.service }}" in
            user-service) script="deploy-user-service-with-build.sh" ;;
            quest-service) script="deploy-quest-service-with-build.sh" ;;
            subscription-service) script="deploy-subscription-service-with-build.sh" ;;
            collaboration-service) script="deploy-collaboration-service-with-build.sh" ;;
            guild-service) script="deploy-guild-service-with-build.sh" ;;
            messaging-service) script="deploy-messaging-service-with-build.sh" ;;
            gamification-service) script="deploy-gamification-service-with-build.sh" ;;
            *) echo "Unknown service: ${{ matrix.service }}"; exit 1 ;;
          esac

          chmod +x "backend/infra/terraform2/scripts/$script"
          "backend/infra/terraform2/scripts/$script" --env "${{ needs.context.outputs.environment }}"

  authorizer:
    runs-on: ubuntu-latest
    needs: [context, changes, backend-tests]
    if: needs.changes.outputs.authorizer_service == 'true'
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.context.outputs.role_arn }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Deploy authorizer stack
        run: |
          chmod +x backend/infra/terraform2/scripts/deploy-authorizer.sh
          backend/infra/terraform2/scripts/deploy-authorizer.sh --env "${{ needs.context.outputs.environment }}"

  connect-service:
    runs-on: ubuntu-latest
    needs: [context, changes]
    if: needs.changes.outputs.connect_service == 'true'
    steps:
      - name: Missing deployment configuration
        run: |
          echo "connect-service changed but no deployment stack or script exists."
          echo "Add a Terraform stack and deployment script for connect-service to enable CI/CD."
          exit 1

  backend-tests:
    runs-on: ubuntu-latest
    needs: [context, changes]
    if: needs.changes.outputs.services == 'true' || needs.changes.outputs.authorizer_service == 'true' || needs.changes.outputs.connect_service == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Setup uv
        uses: astral-sh/setup-uv@v4

      - name: Run service tests
        shell: bash
        run: |
          services=()
          if [[ "${{ needs.changes.outputs.services_has_changes }}" == "true" ]]; then
            services=$(echo '${{ needs.changes.outputs.services_matrix }}' | jq -r '.service[]')
          fi
          if [[ "${{ needs.changes.outputs.authorizer_service }}" == "true" ]]; then
            services="$services"$'\n'"authorizer-service"
          fi
          if [[ "${{ needs.changes.outputs.connect_service }}" == "true" ]]; then
            services="$services"$'\n'"connect-service"
          fi

          if [ -z "$services" ]; then
            echo "No backend service tests to run."
            exit 0
          fi

          while read -r service; do
            [ -z "$service" ] && continue
            echo "Running tests for $service"
            pushd "backend/services/$service" >/dev/null
            uv pip install -r requirements.txt --system
            pytest
            popd >/dev/null
          done <<< "$services"
